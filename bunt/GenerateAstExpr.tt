<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# string[] sep = new string[] { ", " }; #>
<# 
var dic = new Dictionary<string, string>() {
	{ "Assign",    "Token name, Expr value" },
	{ "Binary",    "Expr left, Token oprtor, Expr right" }, // operator is a C# reserved keyword
	{ "Call",      "Expr callee, Token paren, List<Expr> arguments" },
	{ "Get",       "Expr obj, Token name" }, // object is a C# reserved keyword
	{ "Grouping",  "Expr expression" },
	{ "List",      "List<Expr> values" },
	{ "Literal",   "Object value" },
	{ "Logical",   "Expr left, Token oprtor, Expr right" }, // operator is a C# reserved keyword
	{ "Subscript", "Expr obj, Expr index, Expr value" },
	{ "Set",       "Expr obj, Token name, Expr value" }, // object is a C# reserved keyword
	{ "Super",     "Token keyword, Token method" },
	{ "This",      "Token keyword" },
	{ "Unary",     "Token oprtor, Expr right" }, // operator is a C# reserved keyword
	{ "Variable",  "Token name" }
};
#>
// this file is autogenerated using T4
// https://learn.microsoft.com/en-us/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates?source=recommendations&view=vs-2022&tabs=csharp
// https://stackoverflow.com/questions/42353536/how-to-generate-a-simple-class-with-t4

namespace bunt
{
	public abstract class Expr
	{
		public interface IVisitor<T> {
<# foreach (string key in dic.Keys) { #>
		T visit<#= key #>Expr(<#= key #> expr);
<# } #>
		}

<# foreach (string key in dic.Keys) { #>
		public class <#= key #> : Expr
		{
<# foreach (string value in dic[key].Split(sep, StringSplitOptions.RemoveEmptyEntries)) {#>
			public readonly <#= value #>;
<# } #>

			public <#= key #>(<#= dic[key] #>) {
<# foreach (string value in dic[key].Split(sep, StringSplitOptions.RemoveEmptyEntries)) {#>
				this.<#= value.Split(' ')[1] #> = <#= value.Split(' ')[1] #>;
<# } #>
			}

			public override T accept<T>(IVisitor<T> visitor) {
				return visitor.visit<#= key #>Expr(this);
			}
		}
<# } #>

		public abstract T accept<T>(IVisitor<T> visitor);

	}
}